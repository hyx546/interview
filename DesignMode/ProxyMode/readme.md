# 代理模式

在某种情况下，出于种种考虑/限制，一个对象不能直接访问另一个对象，需要一个代理牵线搭桥从而间接的达到访问的目的

- ES6 中的Proxy 代理器

`const proxy = new Proxy(obj, handler)`

1. 第一个参数obj，就是目标对象
2. handler是一个对象，用来定义代理的行为
3. 简单来说，就是当我们通过proxy去访问obj时，handler会对我们的行为作一层拦截，每次访问都需要经过handler这个第三方

- 最常见的四种代理类型： `事件代理、 虚拟代理、 缓存代理和保护代理`

## 事件代理

最常见的就是点击冒泡，把点击事件挂载在父节点上

## 虚拟代理

典型的例子就是：`图片懒加载`

- 懒加载的定义

它是针对图片加载时机： 采取 `先占位，后加载`的方式来展示图片 - 在元素显示之前，给它一个div作占位，当它滚动到可视区域内时，再即时的去加载真实的图片资源， 这样做`既减轻了性能压力，又保住了用户体验（避免造成白屏、卡顿等现象）`

- 图片预加载的定义

预加载是为了避免网络不好，或者图片太大，给用户留白时间过长的尴尬。

常见的操作就是： 让img标签展示一个占位图，然后创建一个Image实例，让这个Image实例的src指向真实的目标图片地址，观察该Image实例加载的情况- 当其对应的真实图片加载完毕后，即已经有了该图片的缓存内容，再将DOM上的img元素的src指向真实的目标图片地址。

此时我们直接去取了目标图片的缓存，所以展示的速度会很快，从占位图到目标图片的时间差会非常小，小到用户注意不到，所以体验会非常好

`virtualImage` 始终存在于js中, 代替真实的DOM发起图片加载请求，完成了图片加载工作

## 缓存代理

`空间换时间` - 当我们需要用到某个已经计算过的值的时候，不想再耗时进行二次计算， 希望直接从内存中取出现有的计算结果
所以需要一个代理，在帮我们计算的同时，进行计算结果的缓存

典型例子，就是对传入的参数进行求和

## 保护代理

首选方案是： es6 的proxy

const proxy = new Proxy();
